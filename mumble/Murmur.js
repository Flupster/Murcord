// !!!
//    THIS FILE IS ONLY COMMITED BECAUSE EASE OF USE
//    IF YOU'RE VISITING FROM THE DISTANT FUTURE THEN PLEASE REGENERATE AND USE A CURRENT VERSION OF Murmur.ice
// !!!
//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const Slice = Ice.Slice;

    let Murmur = _ModuleRegistry.module("Murmur");

    Slice.defineSequence(Murmur, "NetAddressHelper", "Ice.ByteHelper", true);

    /**
     * A connected user.
     **/
    Murmur.User = class
    {
        constructor(session = 0, userid = 0, mute = false, deaf = false, suppress = false, prioritySpeaker = false, selfMute = false, selfDeaf = false, recording = false, channel = 0, name = "", onlinesecs = 0, bytespersec = 0, version = 0, release = "", os = "", osversion = "", identity = "", context = "", comment = "", address = null, tcponly = false, idlesecs = 0, udpPing = 0.0, tcpPing = 0.0)
        {
            this.session = session;
            this.userid = userid;
            this.mute = mute;
            this.deaf = deaf;
            this.suppress = suppress;
            this.prioritySpeaker = prioritySpeaker;
            this.selfMute = selfMute;
            this.selfDeaf = selfDeaf;
            this.recording = recording;
            this.channel = channel;
            this.name = name;
            this.onlinesecs = onlinesecs;
            this.bytespersec = bytespersec;
            this.version = version;
            this.release = release;
            this.os = os;
            this.osversion = osversion;
            this.identity = identity;
            this.context = context;
            this.comment = comment;
            this.address = address;
            this.tcponly = tcponly;
            this.idlesecs = idlesecs;
            this.udpPing = udpPing;
            this.tcpPing = tcpPing;
        }

        _write(ostr)
        {
            ostr.writeInt(this.session);
            ostr.writeInt(this.userid);
            ostr.writeBool(this.mute);
            ostr.writeBool(this.deaf);
            ostr.writeBool(this.suppress);
            ostr.writeBool(this.prioritySpeaker);
            ostr.writeBool(this.selfMute);
            ostr.writeBool(this.selfDeaf);
            ostr.writeBool(this.recording);
            ostr.writeInt(this.channel);
            ostr.writeString(this.name);
            ostr.writeInt(this.onlinesecs);
            ostr.writeInt(this.bytespersec);
            ostr.writeInt(this.version);
            ostr.writeString(this.release);
            ostr.writeString(this.os);
            ostr.writeString(this.osversion);
            ostr.writeString(this.identity);
            ostr.writeString(this.context);
            ostr.writeString(this.comment);
            Murmur.NetAddressHelper.write(ostr, this.address);
            ostr.writeBool(this.tcponly);
            ostr.writeInt(this.idlesecs);
            ostr.writeFloat(this.udpPing);
            ostr.writeFloat(this.tcpPing);
        }

        _read(istr)
        {
            this.session = istr.readInt();
            this.userid = istr.readInt();
            this.mute = istr.readBool();
            this.deaf = istr.readBool();
            this.suppress = istr.readBool();
            this.prioritySpeaker = istr.readBool();
            this.selfMute = istr.readBool();
            this.selfDeaf = istr.readBool();
            this.recording = istr.readBool();
            this.channel = istr.readInt();
            this.name = istr.readString();
            this.onlinesecs = istr.readInt();
            this.bytespersec = istr.readInt();
            this.version = istr.readInt();
            this.release = istr.readString();
            this.os = istr.readString();
            this.osversion = istr.readString();
            this.identity = istr.readString();
            this.context = istr.readString();
            this.comment = istr.readString();
            this.address = Murmur.NetAddressHelper.read(istr);
            this.tcponly = istr.readBool();
            this.idlesecs = istr.readInt();
            this.udpPing = istr.readFloat();
            this.tcpPing = istr.readFloat();
        }

        static get minWireSize()
        {
            return  52;
        }
    };

    Slice.defineStruct(Murmur.User, false, true);

    Slice.defineSequence(Murmur, "IntListHelper", "Ice.IntHelper", true);

    /**
     * A text message between users.
     **/
    Murmur.TextMessage = class
    {
        constructor(sessions = null, channels = null, trees = null, text = "")
        {
            this.sessions = sessions;
            this.channels = channels;
            this.trees = trees;
            this.text = text;
        }

        _write(ostr)
        {
            Murmur.IntListHelper.write(ostr, this.sessions);
            Murmur.IntListHelper.write(ostr, this.channels);
            Murmur.IntListHelper.write(ostr, this.trees);
            ostr.writeString(this.text);
        }

        _read(istr)
        {
            this.sessions = Murmur.IntListHelper.read(istr);
            this.channels = Murmur.IntListHelper.read(istr);
            this.trees = Murmur.IntListHelper.read(istr);
            this.text = istr.readString();
        }

        static get minWireSize()
        {
            return  4;
        }
    };

    Slice.defineStruct(Murmur.TextMessage, true, true);

    /**
     * A channel.
     **/
    Murmur.Channel = class
    {
        constructor(id = 0, name = "", parent = 0, links = null, description = "", temporary = false, position = 0)
        {
            this.id = id;
            this.name = name;
            this.parent = parent;
            this.links = links;
            this.description = description;
            this.temporary = temporary;
            this.position = position;
        }

        _write(ostr)
        {
            ostr.writeInt(this.id);
            ostr.writeString(this.name);
            ostr.writeInt(this.parent);
            Murmur.IntListHelper.write(ostr, this.links);
            ostr.writeString(this.description);
            ostr.writeBool(this.temporary);
            ostr.writeInt(this.position);
        }

        _read(istr)
        {
            this.id = istr.readInt();
            this.name = istr.readString();
            this.parent = istr.readInt();
            this.links = Murmur.IntListHelper.read(istr);
            this.description = istr.readString();
            this.temporary = istr.readBool();
            this.position = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(Murmur.Channel, true, true);

    /**
     * A group. Groups are defined per channel, and can inherit members from parent channels.
     **/
    Murmur.Group = class
    {
        constructor(name = "", inherited = false, inherit = false, inheritable = false, add = null, remove = null, members = null)
        {
            this.name = name;
            this.inherited = inherited;
            this.inherit = inherit;
            this.inheritable = inheritable;
            this.add = add;
            this.remove = remove;
            this.members = members;
        }

        _write(ostr)
        {
            ostr.writeString(this.name);
            ostr.writeBool(this.inherited);
            ostr.writeBool(this.inherit);
            ostr.writeBool(this.inheritable);
            Murmur.IntListHelper.write(ostr, this.add);
            Murmur.IntListHelper.write(ostr, this.remove);
            Murmur.IntListHelper.write(ostr, this.members);
        }

        _read(istr)
        {
            this.name = istr.readString();
            this.inherited = istr.readBool();
            this.inherit = istr.readBool();
            this.inheritable = istr.readBool();
            this.add = Murmur.IntListHelper.read(istr);
            this.remove = Murmur.IntListHelper.read(istr);
            this.members = Murmur.IntListHelper.read(istr);
        }

        static get minWireSize()
        {
            return  7;
        }
    };

    Slice.defineStruct(Murmur.Group, true, true);

    Object.defineProperty(Murmur, 'PermissionWrite', {
        value: 1
    });

    Object.defineProperty(Murmur, 'PermissionTraverse', {
        value: 2
    });

    Object.defineProperty(Murmur, 'PermissionEnter', {
        value: 4
    });

    Object.defineProperty(Murmur, 'PermissionSpeak', {
        value: 8
    });

    Object.defineProperty(Murmur, 'PermissionWhisper', {
        value: 256
    });

    Object.defineProperty(Murmur, 'PermissionMuteDeafen', {
        value: 16
    });

    Object.defineProperty(Murmur, 'PermissionMove', {
        value: 32
    });

    Object.defineProperty(Murmur, 'PermissionMakeChannel', {
        value: 64
    });

    Object.defineProperty(Murmur, 'PermissionMakeTempChannel', {
        value: 1024
    });

    Object.defineProperty(Murmur, 'PermissionLinkChannel', {
        value: 128
    });

    Object.defineProperty(Murmur, 'PermissionTextMessage', {
        value: 512
    });

    Object.defineProperty(Murmur, 'PermissionKick', {
        value: 65536
    });

    Object.defineProperty(Murmur, 'PermissionBan', {
        value: 131072
    });

    Object.defineProperty(Murmur, 'PermissionRegister', {
        value: 262144
    });

    Object.defineProperty(Murmur, 'PermissionRegisterSelf', {
        value: 524288
    });

    Object.defineProperty(Murmur, 'ResetUserContent', {
        value: 1048576
    });

    /**
     * Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.
     **/
    Murmur.ACL = class
    {
        constructor(applyHere = false, applySubs = false, inherited = false, userid = 0, group = "", allow = 0, deny = 0)
        {
            this.applyHere = applyHere;
            this.applySubs = applySubs;
            this.inherited = inherited;
            this.userid = userid;
            this.group = group;
            this.allow = allow;
            this.deny = deny;
        }

        _write(ostr)
        {
            ostr.writeBool(this.applyHere);
            ostr.writeBool(this.applySubs);
            ostr.writeBool(this.inherited);
            ostr.writeInt(this.userid);
            ostr.writeString(this.group);
            ostr.writeInt(this.allow);
            ostr.writeInt(this.deny);
        }

        _read(istr)
        {
            this.applyHere = istr.readBool();
            this.applySubs = istr.readBool();
            this.inherited = istr.readBool();
            this.userid = istr.readInt();
            this.group = istr.readString();
            this.allow = istr.readInt();
            this.deny = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(Murmur.ACL, true, true);

    /**
     * A single ip mask for a ban.
     **/
    Murmur.Ban = class
    {
        constructor(address = null, bits = 0, name = "", hash = "", reason = "", start = 0, duration = 0)
        {
            this.address = address;
            this.bits = bits;
            this.name = name;
            this.hash = hash;
            this.reason = reason;
            this.start = start;
            this.duration = duration;
        }

        _write(ostr)
        {
            Murmur.NetAddressHelper.write(ostr, this.address);
            ostr.writeInt(this.bits);
            ostr.writeString(this.name);
            ostr.writeString(this.hash);
            ostr.writeString(this.reason);
            ostr.writeInt(this.start);
            ostr.writeInt(this.duration);
        }

        _read(istr)
        {
            this.address = Murmur.NetAddressHelper.read(istr);
            this.bits = istr.readInt();
            this.name = istr.readString();
            this.hash = istr.readString();
            this.reason = istr.readString();
            this.start = istr.readInt();
            this.duration = istr.readInt();
        }

        static get minWireSize()
        {
            return  16;
        }
    };

    Slice.defineStruct(Murmur.Ban, true, true);

    /**
     * A entry in the log.
     **/
    Murmur.LogEntry = class
    {
        constructor(timestamp = 0, txt = "")
        {
            this.timestamp = timestamp;
            this.txt = txt;
        }

        _write(ostr)
        {
            ostr.writeInt(this.timestamp);
            ostr.writeString(this.txt);
        }

        _read(istr)
        {
            this.timestamp = istr.readInt();
            this.txt = istr.readString();
        }

        static get minWireSize()
        {
            return  5;
        }
    };

    Slice.defineStruct(Murmur.LogEntry, true, true);

    Slice.defineSequence(Murmur, "TreeListHelper", "Ice.ObjectHelper", false, "Murmur.Tree");

    Murmur.ChannelInfo = Slice.defineEnum([
        ['ChannelDescription', 0], ['ChannelPosition', 1]]);

    Murmur.UserInfo = Slice.defineEnum([
        ['UserName', 0], ['UserEmail', 1], ['UserComment', 2], ['UserHash', 3], ['UserPassword', 4],
        ['UserLastActive', 5], ['UserKDFIterations', 6]]);

    Slice.defineDictionary(Murmur, "UserMap", "UserMapHelper", "Ice.IntHelper", "Murmur.User", false, undefined, undefined);

    Slice.defineDictionary(Murmur, "ChannelMap", "ChannelMapHelper", "Ice.IntHelper", "Murmur.Channel", false, undefined, undefined);

    Slice.defineSequence(Murmur, "ChannelListHelper", "Murmur.Channel", false);

    Slice.defineSequence(Murmur, "UserListHelper", "Murmur.User", false);

    Slice.defineSequence(Murmur, "GroupListHelper", "Murmur.Group", false);

    Slice.defineSequence(Murmur, "ACLListHelper", "Murmur.ACL", false);

    Slice.defineSequence(Murmur, "LogListHelper", "Murmur.LogEntry", false);

    Slice.defineSequence(Murmur, "BanListHelper", "Murmur.Ban", false);

    Slice.defineSequence(Murmur, "IdListHelper", "Ice.IntHelper", true);

    Slice.defineSequence(Murmur, "NameListHelper", "Ice.StringHelper", false);

    Slice.defineDictionary(Murmur, "NameMap", "NameMapHelper", "Ice.IntHelper", "Ice.StringHelper", false, undefined, undefined);

    Slice.defineDictionary(Murmur, "IdMap", "IdMapHelper", "Ice.StringHelper", "Ice.IntHelper", false, undefined, undefined);

    Slice.defineSequence(Murmur, "TextureHelper", "Ice.ByteHelper", true);

    Slice.defineDictionary(Murmur, "ConfigMap", "ConfigMapHelper", "Ice.StringHelper", "Ice.StringHelper", false, undefined, undefined);

    Slice.defineSequence(Murmur, "GroupNameListHelper", "Ice.StringHelper", false);

    Slice.defineSequence(Murmur, "CertificateDerHelper", "Ice.ByteHelper", true);

    Slice.defineSequence(Murmur, "CertificateListHelper", "Murmur.CertificateDerHelper", false);

    Slice.defineDictionary(Murmur, "UserInfoMap", "UserInfoMapHelper", "Murmur.UserInfo._helper", "Ice.StringHelper", false, undefined, undefined);

    const iceC_Murmur_Tree_ids = [
        "::Ice::Object",
        "::Murmur::Tree"
    ];

    /**
     * User and subchannel state. Read-only.
     **/
    Murmur.Tree = class extends Ice.Value
    {
        constructor(c = new Murmur.Channel(), children = null, users = null)
        {
            super();
            this.c = c;
            this.children = children;
            this.users = users;
        }

        _iceWriteMemberImpl(ostr)
        {
            Murmur.Channel.write(ostr, this.c);
            Murmur.TreeListHelper.write(ostr, this.children);
            Murmur.UserListHelper.write(ostr, this.users);
        }

        _iceReadMemberImpl(istr)
        {
            this.c = Murmur.Channel.read(istr, this.c);
            this.children = Murmur.TreeListHelper.read(istr);
            this.users = Murmur.UserListHelper.read(istr);
        }
    };

    Slice.defineValue(Murmur.Tree, iceC_Murmur_Tree_ids[1], false);

    Murmur.MurmurException = class extends Ice.UserException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Ice.UserException;
        }

        static get _id()
        {
            return "::Murmur::MurmurException";
        }

        _mostDerivedType()
        {
            return Murmur.MurmurException;
        }
    };

    /**
     * This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to {@link Server.getUsers}. See {@link User.session}
     **/
    Murmur.InvalidSessionException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidSessionException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidSessionException;
        }
    };

    /**
     * This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
     **/
    Murmur.InvalidChannelException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidChannelException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidChannelException;
        }
    };

    /**
     * This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.
     **/
    Murmur.InvalidServerException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidServerException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidServerException;
        }
    };

    /**
     * This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
     **/
    Murmur.ServerBootedException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::ServerBootedException";
        }

        _mostDerivedType()
        {
            return Murmur.ServerBootedException;
        }
    };

    /**
     * This is thrown if {@link Server.start} fails, and should generally be the cause for some concern.
     **/
    Murmur.ServerFailureException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::ServerFailureException";
        }

        _mostDerivedType()
        {
            return Murmur.ServerFailureException;
        }
    };

    /**
     * This is thrown when you specify an invalid userid.
     **/
    Murmur.InvalidUserException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidUserException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidUserException;
        }
    };

    /**
     * This is thrown when you try to set an invalid texture.
     **/
    Murmur.InvalidTextureException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidTextureException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidTextureException;
        }
    };

    /**
     * This is thrown when you supply an invalid callback.
     **/
    Murmur.InvalidCallbackException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidCallbackException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidCallbackException;
        }
    };

    /**
     * This is thrown when you supply the wrong secret in the calling context.
     **/
    Murmur.InvalidSecretException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidSecretException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidSecretException;
        }
    };

    /**
     * This is thrown when the channel operation would exceed the channel nesting limit
     **/
    Murmur.NestingLimitException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::NestingLimitException";
        }

        _mostDerivedType()
        {
            return Murmur.NestingLimitException;
        }
    };

    /**
     * This is thrown when you ask the server to disclose something that should be secret.
     **/
    Murmur.WriteOnlyException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::WriteOnlyException";
        }

        _mostDerivedType()
        {
            return Murmur.WriteOnlyException;
        }
    };

    /**
     * This is thrown when invalid input data was specified.
     **/
    Murmur.InvalidInputDataException = class extends Murmur.MurmurException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Murmur.MurmurException;
        }

        static get _id()
        {
            return "::Murmur::InvalidInputDataException";
        }

        _mostDerivedType()
        {
            return Murmur.InvalidInputDataException;
        }
    };

    const iceC_Murmur_ServerCallback_ids = [
        "::Ice::Object",
        "::Murmur::ServerCallback"
    ];

    /**
     * Callback interface for servers. You can supply an implementation of this to receive notification
     * messages from the server.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * Note that callbacks are removed when a server is stopped, so you should have a callback for
     * {@link MetaCallback.started} which calls {@link Server.addCallback}.
     * @see MetaCallback
     * @see Server.addCallback
     **/
    Murmur.ServerCallback = class extends Ice.Object
    {
    };

    Murmur.ServerCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.ServerCallback, Murmur.ServerCallbackPrx, iceC_Murmur_ServerCallback_ids, 1,
    {
        "userConnected": [, 2, 2, , , [[Murmur.User]], , , , ],
        "userDisconnected": [, 2, 2, , , [[Murmur.User]], , , , ],
        "userStateChanged": [, 2, 2, , , [[Murmur.User]], , , , ],
        "userTextMessage": [, 2, 2, , , [[Murmur.User], [Murmur.TextMessage]], , , , ],
        "channelCreated": [, 2, 2, , , [[Murmur.Channel]], , , , ],
        "channelRemoved": [, 2, 2, , , [[Murmur.Channel]], , , , ],
        "channelStateChanged": [, 2, 2, , , [[Murmur.Channel]], , , , ]
    });

    Object.defineProperty(Murmur, 'ContextServer', {
        value: 1
    });

    Object.defineProperty(Murmur, 'ContextChannel', {
        value: 2
    });

    Object.defineProperty(Murmur, 'ContextUser', {
        value: 4
    });

    const iceC_Murmur_ServerContextCallback_ids = [
        "::Ice::Object",
        "::Murmur::ServerContextCallback"
    ];

    /**
     * Callback interface for context actions. You need to supply one of these for {@link Server.addContext}. 
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     **/
    Murmur.ServerContextCallback = class extends Ice.Object
    {
    };

    Murmur.ServerContextCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.ServerContextCallback, Murmur.ServerContextCallbackPrx, iceC_Murmur_ServerContextCallback_ids, 1,
    {
        "contextAction": [, 2, 2, , , [[7], [Murmur.User], [3], [3]], , , , ]
    });

    const iceC_Murmur_ServerAuthenticator_ids = [
        "::Ice::Object",
        "::Murmur::ServerAuthenticator"
    ];

    /**
     * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
     * synchronously. If the response lags, the entire murmur server will lag.
     * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
     * deadlock the server.
     **/
    Murmur.ServerAuthenticator = class extends Ice.Object
    {
    };

    Murmur.ServerAuthenticatorPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.ServerAuthenticator, Murmur.ServerAuthenticatorPrx, iceC_Murmur_ServerAuthenticator_ids, 1,
    {
        "authenticate": [, 2, 2, , [3], [[7], [7], ["Murmur.CertificateListHelper"], [7], [1]], [[7], ["Murmur.GroupNameListHelper"]], , , ],
        "getInfo": [, 2, 2, , [1], [[3]], [["Murmur.UserInfoMapHelper"]], , , ],
        "nameToId": [, 2, 2, , [3], [[7]], , , , ],
        "idToName": [, 2, 2, , [7], [[3]], , , , ],
        "idToTexture": [, 2, 2, , ["Murmur.TextureHelper"], [[3]], , , , ]
    });

    const iceC_Murmur_ServerUpdatingAuthenticator_ids = [
        "::Ice::Object",
        "::Murmur::ServerAuthenticator",
        "::Murmur::ServerUpdatingAuthenticator"
    ];

    /**
     * Callback interface for server authentication and registration. This allows you to support both authentication
     * and account updating.
     * You do not need to implement this if all you want is authentication, you only need this if other scripts
     * connected to the same server calls e.g. {@link Server.setTexture}.
     * Almost all of these methods support fall through, meaning murmur should continue the operation against its
     * own database.
     **/
    Murmur.ServerUpdatingAuthenticator = class extends Ice.Object
    {
        static get _iceImplements()
        {
            return [
                Murmur.ServerAuthenticator
            ];
        }
    };

    Murmur.ServerUpdatingAuthenticatorPrx = class extends Ice.ObjectPrx
    {
        static get _implements()
        {
            return [
                Murmur.ServerAuthenticatorPrx];
        }
    };

    Slice.defineOperations(Murmur.ServerUpdatingAuthenticator, Murmur.ServerUpdatingAuthenticatorPrx, iceC_Murmur_ServerUpdatingAuthenticator_ids, 2,
    {
        "registerUser": [, , , , [3], [["Murmur.UserInfoMapHelper"]], , , , ],
        "unregisterUser": [, , , , [3], [[3]], , , , ],
        "getRegisteredUsers": [, 2, 2, , ["Murmur.NameMapHelper"], [[7]], , , , ],
        "setInfo": [, 2, 2, , [3], [[3], ["Murmur.UserInfoMapHelper"]], , , , ],
        "setTexture": [, 2, 2, , [3], [[3], ["Murmur.TextureHelper"]], , , , ]
    });

    const iceC_Murmur_Server_ids = [
        "::Ice::Object",
        "::Murmur::Server"
    ];

    /**
     * Per-server interface. This includes all methods for configuring and altering
     * the state of a single virtual server. You can retrieve a pointer to this interface
     * from one of the methods in {@link Meta}.
     **/
    Murmur.Server = class extends Ice.Object
    {
    };

    Murmur.ServerPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.Server, Murmur.ServerPrx, iceC_Murmur_Server_ids, 1,
    {
        "isRunning": [, 2, 2, , [1], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "start": [, , , , , , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException,
            Murmur.ServerFailureException
        ], , ],
        "stop": [, , , , , , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "delete": ["_delete", , , , , , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "id": [, 2, 2, , [3], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "addCallback": [, , , , , [["Murmur.ServerCallbackPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "removeCallback": [, , , , , [["Murmur.ServerCallbackPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setAuthenticator": [, , , , , [["Murmur.ServerAuthenticatorPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getConf": [, 2, 2, , [7], [[7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.WriteOnlyException
        ], , ],
        "getAllConf": [, 2, 2, , ["Murmur.ConfigMapHelper"], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "setConf": [, 2, 2, , , [[7], [7]], ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "setSuperuserPassword": [, 2, 2, , , [[7]], ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getLog": [, 2, 2, , ["Murmur.LogListHelper"], [[3], [3]], ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getLogLen": [, 2, 2, , [3], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getUsers": [, 2, 2, , ["Murmur.UserMapHelper"], , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getChannels": [, 2, 2, , ["Murmur.ChannelMapHelper"], , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getCertificateList": [, 2, 2, , ["Murmur.CertificateListHelper"], [[3]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getTree": [, 2, 2, , ["Murmur.Tree", true], , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , true],
        "getBans": [, 2, 2, , ["Murmur.BanListHelper"], , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setBans": [, 2, 2, , , [["Murmur.BanListHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "kickUser": [, , , , , [[3], [7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getState": [, 2, 2, , [Murmur.User], [[3]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "setState": [, 2, 2, , , [[Murmur.User]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "sendMessage": [, , , , , [[3], [7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "hasPermission": [, , , , [1], [[3], [3], [3]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "effectivePermissions": [, 2, 2, , [3], [[3], [3]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "addContextCallback": [, , , , , [[3], [7], [7], ["Murmur.ServerContextCallbackPrx"], [3]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "removeContextCallback": [, , , , , [["Murmur.ServerContextCallbackPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getChannelState": [, 2, 2, , [Murmur.Channel], [[3]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setChannelState": [, 2, 2, , , [[Murmur.Channel]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.NestingLimitException,
            Murmur.ServerBootedException
        ], , ],
        "removeChannel": [, , , , , [[3]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "addChannel": [, , , , [3], [[7], [3]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.NestingLimitException,
            Murmur.ServerBootedException
        ], , ],
        "sendMessageChannel": [, , , , , [[3], [1], [7]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getACL": [, 2, 2, , , [[3]], [["Murmur.ACLListHelper"], ["Murmur.GroupListHelper"], [1]],
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "setACL": [, 2, 2, , , [[3], ["Murmur.ACLListHelper"], ["Murmur.GroupListHelper"], [1]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "addUserToGroup": [, 2, 2, , , [[3], [3], [7]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "removeUserFromGroup": [, 2, 2, , , [[3], [3], [7]], ,
        [
            Murmur.InvalidChannelException,
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "redirectWhisperGroup": [, 2, 2, , , [[3], [7], [7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidSessionException,
            Murmur.ServerBootedException
        ], , ],
        "getUserNames": [, 2, 2, , ["Murmur.NameMapHelper"], [["Murmur.IdListHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getUserIds": [, 2, 2, , ["Murmur.IdMapHelper"], [["Murmur.NameListHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "registerUser": [, , , , [3], [["Murmur.UserInfoMapHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "unregisterUser": [, , , , , [[3]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "updateRegistration": [, 2, 2, , , [[3], ["Murmur.UserInfoMapHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getRegistration": [, 2, 2, , ["Murmur.UserInfoMapHelper"], [[3]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getRegisteredUsers": [, 2, 2, , ["Murmur.NameMapHelper"], [[7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "verifyPassword": [, 2, 2, , [3], [[7], [7]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "getTexture": [, 2, 2, , ["Murmur.TextureHelper"], [[3]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "setTexture": [, 2, 2, , , [[3], ["Murmur.TextureHelper"]], ,
        [
            Murmur.InvalidSecretException,
            Murmur.InvalidTextureException,
            Murmur.InvalidUserException,
            Murmur.ServerBootedException
        ], , ],
        "getUptime": [, 2, 2, , [3], , ,
        [
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "updateCertificate": [, 2, 2, , , [[7], [7], [7]], ,
        [
            Murmur.InvalidInputDataException,
            Murmur.InvalidSecretException,
            Murmur.ServerBootedException
        ], , ],
        "startListening": [, 2, 2, , , [[3], [3]], , , , ],
        "stopListening": [, 2, 2, , , [[3], [3]], , , , ],
        "isListening": [, 2, 2, , [1], [[3], [3]], , , , ],
        "getListeningChannels": [, 2, 2, , ["Murmur.IntListHelper"], [[3]], , , , ],
        "getListeningUsers": [, 2, 2, , ["Murmur.IntListHelper"], [[3]], , , , ],
        "sendWelcomeMessage": [, 2, 2, , , [["Murmur.IdListHelper"]], , , , ]
    });

    const iceC_Murmur_MetaCallback_ids = [
        "::Ice::Object",
        "::Murmur::MetaCallback"
    ];

    /**
     * Callback interface for Meta. You can supply an implementation of this to receive notifications
     * when servers are stopped or started.
     * If an added callback ever throws an exception or goes away, it will be automatically removed.
     * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
     * complete before continuing processing.
     * @see ServerCallback
     * @see Meta.addCallback
     **/
    Murmur.MetaCallback = class extends Ice.Object
    {
    };

    Murmur.MetaCallbackPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.MetaCallback, Murmur.MetaCallbackPrx, iceC_Murmur_MetaCallback_ids, 1,
    {
        "started": [, , , , , [["Murmur.ServerPrx"]], , , , ],
        "stopped": [, , , , , [["Murmur.ServerPrx"]], , , , ]
    });

    Slice.defineSequence(Murmur, "ServerListHelper", "Murmur.ServerPrx", false);

    const iceC_Murmur_Meta_ids = [
        "::Ice::Object",
        "::Murmur::Meta"
    ];

    /**
     * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
     **/
    Murmur.Meta = class extends Ice.Object
    {
    };

    Murmur.MetaPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(Murmur.Meta, Murmur.MetaPrx, iceC_Murmur_Meta_ids, 1,
    {
        "getServer": [, 2, 2, , ["Murmur.ServerPrx"], [[3]], ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "newServer": [, , , , ["Murmur.ServerPrx"], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getBootedServers": [, 2, 2, , ["Murmur.ServerListHelper"], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getAllServers": [, 2, 2, , ["Murmur.ServerListHelper"], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getDefaultConf": [, 2, 2, , ["Murmur.ConfigMapHelper"], , ,
        [
            Murmur.InvalidSecretException
        ], , ],
        "getVersion": [, 2, 2, , , , [[3], [3], [3], [7]], , , ],
        "addCallback": [, , , , , [["Murmur.MetaCallbackPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException
        ], , ],
        "removeCallback": [, , , , , [["Murmur.MetaCallbackPrx"]], ,
        [
            Murmur.InvalidCallbackException,
            Murmur.InvalidSecretException
        ], , ],
        "getUptime": [, 2, 2, , [3], , , , , ],
        "getSlice": [, 2, 2, , [7], , , , , ],
        "getSliceChecksums": [, 2, 2, , ["Ice.SliceChecksumDictHelper"], , , , , ]
    });
    exports.Murmur = Murmur;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self.Ice._require : window.Ice._require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self : window));
